## 왜?

자연적 순서를 가지게 됨

`Comparable`을 구현한 객체들의 배열을 정렬하는 것이 간단하고 유지하기 쉬움

```java
Array.sort(a)
```

검색, 최대/최소치 계산하기도 간단

```java
public WordList {
    public static void main(String[] args) {
        Set<String> s = new TreeSet<>();
		Collections.addAll(s, args);
        System.out.println(s);
    }
}
```

시간적 선후관계처럼 명확한 자연적 순서를 따르는 __값 클래스__를 구현할 때는 `Comparable` 인터페이스를 구현할 것을 반드시 고려해 봐야함

## `compareTo` 일반 규약

- 주어진 객체보다 작으면 **음수**, 같으면 **0**, 크면 **양수**를 반환

- 비교 불가능한 자료형인 경우, `ClassCastException`

- 객체 참조를 비교하는 방향을 뒤집어도 객체 간 대소 관계는 그대로 유지되어야 함 = **A < B < C <-> C > B > A**

- `equals` 규약과 마찬가지로 **반사성, 대칭성, 추이성**을 만족해야 함

- _(원래 객체를 필드로 포함하는)_ 새로운 클래스를 만들 때, 원래 클래스의 객체를 반환하는 **View 메서드**를 추가

- `compareTo`를 통한 동치성 검사 결과는 __일반적으로__ `equals`와 같아야 함 > ***강력한 권고사항***

## `compareTo`와 `equals`의 구현 차이

- `Comparable` 인터페이스는 자료형을 인자로 받는 **제네릭 인터페이스** > 객체의 형 검사와 변환이 필요없음

## `compareTo` 구현 주의사항

- **정수형**의 기본 자료형은 **관계 연산자** `<`, `>` 사용
- **실수형**은 `Float.compare`, `Double.compare`를 사용
- **배열**은 **원소**마다 적용
- **클래스**는 **중요 필드**부터 차례로 비교 > **중요 필드**를 **diff**로 계산할 때는 ***음수가 아닐때만 사용할 것*** *(p.89)*

