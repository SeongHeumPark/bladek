## 왜?

- **정보은닉**이 깨질 수 있음
- 장기적으로 해야할 일이 많아짐

## `Serializable`의 문제점

- 클래스를 릴리스하고 나면 유연하게 수정하기 어려워진다.
- **버그**나 **보안**에 취약점이 발생할 가능성이 높아진다.
- 새 버전 클래스를 내놓기 위한 테스트 부담이 늘어난다.

## 클래스를 릴리스하고 나면 유연하게 수정하기 어려워진다.

- `Serializable`을 구현하면 해당 클래스의 **바이트 스트림 인코딩**이 공개됨
  즉, **공개 API**가 되어버림

- 기본 직렬화 형식을 이용하면 `private`이나 `package-private`이 의미가 없어짐

  즉, **정보은닉**이 깨짐

- **직렬화 UID**는 클래스의 진화를 막는 `Serializable`의 간단한 사례
  UID가 맞지 않으면 `InvalidClassException` 발생

## 버그나 보안에 취약점이 발생할 가능성이 높아진다.

- 직렬화/역직렬화는 **언어 외적인 객체 생성 메카니즘**
- 역직렬화는 **생성자와 동일한 이슈**를 가짐
  **모든 불변식** 보장 X, **공격자**로 부터 보호 X

## 새 버전 클래스를 내놓기 위한 테스트 부담이 늘어난다.

- 테스트 코드로 체크가 불가능
  즉, **테스트 자동화 불가**
  why? **이진 호환성**뿐만 아니라 **의미 호환성**(원래 객체에 충실한 사본인가?)까지 체크해야 함

## 실만 있는 것은 아니다.

- 객체 전송, 저장을 위해선 필수
- 그러니, 클래스를 설계할 때 이를 꼼꼼히 따져보라.

## 주의사항

- **계승**을 염두에 둔다면 `Serializable`은 구현하지 않는 것이 바람직하다.
  - 물론 구현한 경우도 있음
    `Throwable`, `Component`, `HttpServlet` 등

  - **계승**을 고려했을 때, **위배되는 불변식**이 있는 경우 `readObjectNoData()` 메서드를 반드시 추가하라.
    `readObjectNoData()` 메서드는 Java 1.4부터 지원

    ```java
    // 상태유지 계승가능 직렬화 가능
    // 클래스에 대한 readObjectNoData() 메서드
    private void readObjectNoData() throws InvalidObjectException {
    	throw new InvalidObjectException("Stream data required");
    }
    ```

- **인터페이스**도 가급적 `Serializable`을 계승하지 마라.

- **계승**을 고려해 설계한 직렬화 불가능 클래스에는 **무인자 생성자**를 제공하는 것이 어떨지 고려하라.

- **내부 클래스**에는 `Serializable`을 구현하면 안 된다.

  - 내부 클래스의 기본 직렬화 형식은 정의될 수 없음
  - 단, **정적 멤버 클래스**는 구현해도 됨

## 정리

- `Serializable` 구현은 반드시 신중할 것