## 왜?

- 정확하게 사용하기 어려움

## 병행 컬렉션 & 동기자

- java.util.concurent에 포함된 유틸리티 (실행자 프레임워크도 여기 있지)

## 병행 컬렉션

- `List`, `Queue`, `Map` 등의 표준 컬렉션 인터페이스에 대한 고성능 병행 컬렉션 구현을 제공
- 동기화를 내부적으로 처리
- 즉, 컬렉션 외부에서 동기화를 처리하는 것은 불가능 (성능만 떨어짐)
- 클라이언트는 병행 컬렉션에 대한 메서드 호출을 원자적으로 작성할 수 없다.
- **상태 종속 변경 연산**
  - 몇 가지 기본 연산들을 하나의 원자적 연산으로 묶은 것
  - ex) `ConcurrentMap`의 `putIfAbsent(key, value)` (p.374~375 참고)
- 반드시 **병행 컬렉션**을 이용하자.
- **봉쇄 연산**
  - 성공적으로 수행될 수 있을 때까지 대기할 수 있도록 확장됨
  - ex) `BlockingQueue` (p.376 참고)

##  동기자

- 스레드들이 서로를 기다릴 수 있도록 하여 상호 협력이 가능하게 한다.
- **CountDownLatch**, **Semaphore**, CyclicBarrier, Exchanger

## 카운트다운 래치

- 일회성 배리어
- 하나 이상의 스레드가 작업을 마칠 때까지 다른 스레들들이 대기할 수 있도록 한다.
- p. 377 예제 참고

## `System.nanoTime`

- 특정 구간의 실행 시간을 잴 때 사용

## `wait`나 `notify`를 유지시켜야 한다면...

- `wait`의 경우 **표준 숙어**를 따라라.

  ```java
  // wait 메서드를 사용하는 표준 숙어
  synchronized (obj) {
  	while (조건) {
      	obj.wait();
  	}
  }
  ```

- `wait` 호출 전에 조건 검사하고 조건을 만족하지 않을 때 실행하는 것은 **생존 오류**를 피하기 위해 필요함

- `wait`가 실행되고 나서 다시 조건을 검사하는 것은 **안전 오류**를 피하기 위해 필요함

- 조건이 만족되지 않았는데 **스레드가 깨어나는 이유** (p.379 참고)

- `notify` 대신 `notifyAll`을 사용하라.

  - 악의적으로 `wait`를 호출하는 상황에 대비할 수 있음

## 정리

- 새로 만드는 프로그램에는 `wait`, `notify`를 사용할 일이 없다.