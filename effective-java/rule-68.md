## 스레드보다는 실행자와 태스크를 이용하라.

### 왜?

- 유연성
- 간단한 코드

### 실행자 프레임워크

- java.util.concurrent

- 자바 1.5부터 추가

- 유연성이 높은 인터페이스 기반 태스크 실행 프레임워크

### 실행자 서비스

- 예제
  ```java
  // 실행자 생성
  ExecutorService executor = Executor.newSingleThreadExecutor();

  // 실행
  executor.execute(runnable);

  // 종료
  executor.shutdown();
  ```

- 장점

  - 특정 태스크가 종료되기를 기다릴 수 있다.
  - 임의의 태스크들이 종료되기를 기다릴 수 있다.
  - 실행자 서비스가 자연스럽게 종료되기를 기다릴 수 있다.
  - 태스크가 끝날 때마다 그 결과를 차례로 가져올 수 있다.
  - 기타 등등

### 스레드 풀

- 큐의 작업을 처리하는 스레드를 여러개 만들고 싶을 때 사용
- 실행자 서비스를 생성하는 __정적 팩터리 메서드__
- 스레드 고정 or 가변적으로 수를 정할 수 있다.
- `Executors.newCacheThreadPool`: 작은 프로그램, 부하가 크지 않은 서버
  - 설정 노필요
  - 보통 많은 일을 잘 처리함
  - 작업 큐에 들어가는 것이 아니라, 실행을 담당하는 스레드로 바로 넘김
- `Executors.newFixedThreadPool`: 부하가 심한 환경의 서버
  - 스레드 수가 고정된 풀을 만듦
- `ThreadPoolExecutor`: 최대한 많은 부분을 직접 제어함

### 주의 사항

- __작업 큐__를 __손수 구현__하거나 __스레드__를 __직접 이용__하는 것은 __삼가하고 피해야 한다.__

### 태스크

- `Runnable`: 값을 반환하지 않는 태스크
- `Callable`: 값을 반환하는 태스크
- 태스크를 실행하는 일반 메커니즘 = __실행자 서비스__

### 타이머

- 실행자 프레임워크에는 `ScheduledThreadPoolExecutor`도 정의됨
- 사용하기 편하며 유연성이 높다.
- 여러 스레드를 이용한다.
- 태스크 안에서 __무점검 예외__가 발생한 상황도 우아하게 복구한다.

### 정리

- 태스크와 실행자 서비스를 분리해서 생각하게 되면 실행 정책을 더욱 유연하게 정할 수 있다.
- 핵심은 실행자 프레임워크는 태스크를 실행하는 부분을 담당한다는 것