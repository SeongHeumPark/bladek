## `equals`를 재정의하지 않아도 되는 경우

- 객체가 고유할 때
- 논리적 동일성 검사 방법이 있건 없건 상관없을 때
- 상위 클래스에서 재정의한 `equals`가 하위 클래스에서 사용하기 적당할 때
- 클래스가 private 또는 package-private로 선언되었고, `equals` 메서드를 호출할 일이 없을 때

## `equals`를 재정의하는 것이 바람직한 경우

- 클래스가 논리적 동일성의 개념을 지원할 때
- 상위 클래스에서 재정의한 `equals`가 하위 클래스의 필요를 충족시키지 못할 때

## `equals`를 재정의할 필요가 없는 경우

- 값 클래스일 때 > **최대 하나의 객체만 가질 수 있는 클래스**
- **Singleton, enum**

## `equals`가 준수해야 하는 일반 규약 = 동치관계

- **반사성**: `x.equals(x)`는 `true`
- **대칭성**: `x.equals(y)`는 `y.equals(x)`가 `true`일 때, `true`
- **추이성**: `x.equals(y)`가 `true`이고 `y.equals(z)`가 `true`이면, `x.equals(z)`도 `true`
- **일관성**: `equals`를 통해 비교되는 정보에 아무 변화가 없다면 `x.equals(y)` 결과는 호출 횟수와 관계없이 항상 같음
- `null` 아닌 참조 `x`에 대해서, `x.equals(null)`은 항상 `false`
- 비교하는 값들은 `null`이 아님

### 반사성
- 나는 나, 너는 너 → 일부러 깨기 힘듦

### 대칭성
- `CaseInsenitiveString`과 `String`

   ``` java
   public final class CaseInsensitiveString {
       private final String s;
   
       public CaseInsensitiveString(String s) {
   		if (s == null) {
   			throw new NullPointerException();
           }
           this.s = s;
       }
    
   	// 대칭성이 깨지는 equals() 함수
   	@Override
   	public boolean equals(Object o) {
   		if (o instanceof CaseInsensitiveString) {
   			return s.equalsIgnoreCase(((CaseInsensitiveString) o).s);
   		}
      
   		if (o instanceof String) {
   			return s.equalsIgnoreCase((String) o);
   		}
      
   		return false;
   	}
    
   	// 대칭성이 깨지지 않는 equals() 함수
   	@Override
   	public boolean equals(Object s) {
   		if (o instanceof CaseInsensitiveString) {
   			return ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);
   		}
      
   		return false;
   	}
  }
  ```

### 추이성
- x와 y가 같고 y와 z가 같으면 x와 z도 같다. > *명제에서 많이보던 것*
  
- 객체 생성 가능 클래스를 계승하여 새로운 값 컴포넌트를 추가하면 `equals` 규약을 어기지 않을 수 없다.

- **리스코프 대체 원칙**
  어떤 자료형의 중요한 속성은 하위 자료형에도 그대로 유지되어서...
  그 자료형에도 잘 동작해야 한다는 원칙...

- 자바에서는 `Timestamp`와 `Date` 클래스가 있다. _(둘이 같이 쓰지 말라는 경고가 있음)_

- 문제를 깔끔히 피하는 방법: **View 메서드**

  ```java
  public class ColorPoint {
    private final Point point;
    private final Color color;
    
    ...
    
    /**
     * ColorPoint의 Point 뷰 반환
     */
    public Point asPoint() {
      return point;
    }
    
    @Override
    public boolean equals(Object o) {
      if (!(o instanceof ColorPoint)) {
        return false;
      }
      
      ColorPoint cp = (ColorPoint) o;
      
      return cp.asPoint().equals(point) && cp.color.equals(color);
    }
  }
  ```

### 일관성
- 일단 같다고 판단되면 무조건 같다.
- 신뢰성이 보장되지 않은 자원들을 비교하는 `equals`를 구현하는 것은 삼가하라.
  **`URL` 클래스**가 그러하다. > 같은 ip라고 같은 결과가 나오는가?

### `null`에 대한 비 동치성
- `null`이랑 비교해서 같을 수 있는 것은 아무것도 없다.
- `instanceof` 키워드는 `null` 체크도 해줌 > *클라우드 소스에서 수정할 부분이 있지 않을까?*

## 훌륭한 `equals`를 구현하기 위한 지침 _(정리)_

- `==` 연산자를 사용하여 equals의 인자가 자기 자신인지 검사하라.
- `instanceof`를 사용하여 인자의 자료형이 정확한지 검사하라.
- `equals`의 인자를 정확한 자료형으로 반환하라.
- __중요 필드__ 각각이 인자로 주어진 객체의 해당 필드와 일치하는지 검사하라.
- `equals` 메서드 구현을 끝냈다면, **대칭성**, **추이성**, **일관성** 세 속성이 만족되는지 검토하라.

## 주의사항

- `equals`를 구현할 때는 `hashCode`도 재정의하라.
- `equals` 메서드 인자를 `Object`에서 다른 것으로 바꾸지 마라.